use std::env;
use std::error::Error;
use std::fs::File;
use std::io::Read;
use std::process::Command;

use clap::{Arg, App, ArgMatches};
use syn::{Item, Stmt, Meta, NestedMeta, parse_quote};
use quote::quote;

static USR_LIB_NAME: &'static str = "usr";

fn main() {
    let matches = App::new("Proxy Generator")
                            .version(env!("CARGO_PKG_VERSION"))
                            .about("Generate proxy")
                            .arg(Arg::with_name("INPUT")
                                .help("Sets the input file to use.")
                                .required(true)
                                .index(1))
                            .arg(Arg::with_name("OUTPUT")
                                .help("Sets the output file to use.")
                                .required(true)
                                .index(2))
                            .arg(Arg::with_name("directory-mode")
                                .long("directory-mode")
                                .help("Operate on a directory instead of a file uf set."))
                            .arg(Arg::with_name("replace-definitions")
                                .long("replace-definitions")
                                .help("Replace definitions with use statements if set."))
                            .arg(Arg::with_name("remove-prelude")
                                .long("remove-prelude")
                                .help("Remove prelude if set."))
                            .arg(Arg::with_name("inject-dependency")
                                .long("inject-dependency")
                                .help("Inject dependency if set."))
                            .arg(Arg::with_name("fix-use")
                                .long("fix-use")
                                .help("Fix use statements if set."))
                            .get_matches();


    run(&matches).unwrap();
}



fn run(args: &ArgMatches) -> Result<(), Box<dyn Error>> {
    let input_path = args.value_of("INPUT").unwrap();
    let output_path = args.value_of("OUTPUT").unwrap();

    if !args.is_present("directory-mode") {
        return run_single_file(args, &input_path, &output_path);
    }

    // Blindly copy input to output so we don't have to create the directory ourselves
    Command::new("bash")
        .arg("-c")
        .arg(format!("cp -r {} {}", input_path, output_path))
        .output()?;

    let find_output = Command::new("bash")
        .arg("-c")
        .arg(format!("find {} -name '*.rs'", output_path))
        .output()?;

    let files = String::from_utf8(find_output.stdout)?;

    for file in files.trim().split("\n") {
        run_single_file(&args, &file, &file)?
    }

    Ok(())
}

fn run_single_file(args: &ArgMatches, input_path: &str, output_path: &str) -> Result<(), Box<dyn Error>> {
    println!("Running cleanser on {}, outputing to {}", input_path, output_path);

    let mut file = File::open(input_path)?;
    let mut content = String::new();
    file.read_to_string(&mut content)?;

    let mut ast = syn::parse_file(&content)?;

    // Remove structs definitions
    // They will be defined in `use`
    if args.is_present("replace-definitions") {
        replace_definitions(&mut ast);
    }

    // Remove prelude stuff
    if args.is_present("remove-prelude") {
        remove_prelude(&mut ast);
    }

    // Inject dependencies
    if args.is_present("inject-dependency") {
        inject_dependency(&mut ast)?;
    }

    // Fix imports
    if args.is_present("fix-use") {
        fix_import(&mut ast)?;
    }


    // Write output
    let output = quote!(#ast).to_string();
    std::fs::write(output_path, output)?;

    Ok(())
}

/// Remove unwanted stuff generated by cargo-expand
fn remove_prelude(ast: &mut syn::File) {
    // Remove `#![feature(prelude_import)]`
    ast.attrs.retain(|attr| {
        if let Ok(Meta::List(meta)) = attr.parse_meta() {
            if !meta.path.is_ident("feature") {
                return true;
            } 

            for meta in meta.nested {
                if let NestedMeta::Meta(meta) = meta {
                    if meta.path().is_ident("prelude_import") {
                        return false;
                    }
                } 
            }
        }

        true
    });

    ast.items.retain(|item| {
        // Remove ```
        // #[prelude_import]
        // use core::prelude::v1::*;
        // ```
        if let Item::Use(item) = item {
            for attr in &item.attrs {
                if let Ok(meta) = attr.parse_meta() {
                    if meta.path().is_ident("prelude_import") {
                        return false;
                    }
                } 
            }
        }

        // Remove 
        // ```
        // #[macro_use]
        // extern crate compiler_builtins;
        // #[macro_use]
        // extern crate core;
        // ```
        if let Item::ExternCrate(item) = item {
            let ident = item.ident.to_string();
            if ident == "compiler_builtins" || ident == "core" {
                return false;
            } 
        }

        true
    });
}

/// Inject necessary dependency and features for generating the proxy
fn inject_dependency(ast: &mut syn::File) -> Result<(), Box<dyn Error>> {
    // Inject required features
    ast.attrs.push(
        parse_quote!(#![feature(global_asm, type_ascription, core_intrinsics, fmt_internals, derive_clone_copy, structural_match, rustc_private, derive_eq, extended_key_value_attributes)])
    );


    // Recursively inject import statements in each module
    for item in ast.items.iter_mut() {
        inject_import_recursive(item)?;
    }

    Ok(())
}

/// Recursively inject import statements in each module
fn inject_import_recursive(item: &mut Item) -> Result<(), Box<dyn Error>> {
    match item {
        Item::Mod(md) => {
            if let Some((_, content)) = &mut md.content {
                for item in content.iter_mut() {
                    inject_import_recursive(item)?;
                }

                let injected_import_statements: Vec<Stmt> =  parse_quote! {
                    use codegen_proc::redidl_resolve_module_and_generate_proxy as interface;
                    use codegen_proc::redidl_generate_proxy;
                    use unwind::trampoline;
                    use libsyscalls::syscalls::{sys_get_current_domain_id, sys_update_current_domain_id, sys_discard_cont};
                };
    
                let mut injected_import_statements: Vec<Item> = injected_import_statements
                                                    .into_iter()
                                                    .map(|stmt| {
                                                        match stmt {
                                                            Stmt::Item(item) => item,
                                                            _ => unreachable!(),
                                                        }
                                                    })
                                                    .collect();
                
                // Prepend the injected statments to the current statements
                injected_import_statements.append(content);
                *content = injected_import_statements;
            }
        },
        _ => {},
    };

    Ok(())
}

fn fix_import(ast: &mut syn::File) -> Result<(), Box<dyn Error>> {
    for item in ast.items.iter_mut() {
        fix_import_recursive(item)?;
    }

    Ok(())
}

/// Recursively fix import statements in each module
fn fix_import_recursive(item: &mut syn::Item) -> Result<(), Box<dyn Error>> {
    match item {
        Item::Mod(md) => {
            if let Some((_, content)) = &mut md.content {
                for item in content.iter_mut() {
                    fix_import_recursive(item)?;
                }
            }
        },
        Item::Use(item) => {
            if let syn::UseTree::Path(path) = &mut item.tree {
                if path.ident.to_string() == "crate" {
                    path.ident = syn::Ident::new(USR_LIB_NAME, path.ident.span());
                }
            }
        }
        _ => {},
    };

    Ok(())
}

fn replace_definitions(ast: &mut syn::File) {
    replace_definitions_recursive(&mut ast.items)
}

/// Recursively remove struct definitions in each module
fn replace_definitions_recursive(items: &mut Vec<syn::Item>) {
    for item in items.iter_mut() {
        match item {
            Item::Const(x) => replace_if_public!(item, x),
            Item::Enum(x) => replace_if_public!(item, x),
            Item::Static(x) => replace_if_public!(item, x),
            Item::Struct(x) => replace_if_public!(item, x),
            Item::TraitAlias(x) => replace_if_public!(item, x),
            Item::Type(x) => replace_if_public!(item, x),
            Item::Union(x) => replace_if_public!(item, x),
            Item::Trait(tra) => {
                // Replace the trait only if it is not a interface
                let is_interface = tra.attrs.iter().find(
                    |attr| {
                        if let Ok(syn::Meta::Path(meta)) = attr.parse_meta(){
                            if meta.is_ident("interface") {
                                return true;
                            }
                        }
                        false
                    }
                );
                if is_interface.is_none() {
                    replace_if_public!(item, tra);
                }
            },
            Item::Mod(md) => {
                if let Some((_, items)) = &mut md.content {
                    replace_definitions_recursive(items)
                }
            },
            _ => {},
        }
    };
}


#[macro_export]
macro_rules! replace_if_public {
    ($dest: ident, $item: ident) => {
        if let syn::Visibility::Public(_) = $item.vis {
            let ident = &$item.ident;
            let st: syn::ItemStruct = parse_quote! {
                #[redidl_generate_import]
                #[module_path = module_path!()]
                struct #ident {}
            };
            *$dest = syn::Item::Struct(st);
        }
    };
}

