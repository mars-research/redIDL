use std::env;
use std::error::Error;
use std::env::VarError;
use std::fs::File;
use std::io::Read;

use clap::{Arg, App, ArgMatches};
use syn::{Item, Stmt, Meta, NestedMeta, parse_quote};
use quote::quote;

static USR_LIB_NAME: &'static str = "usr";

fn main() {
    let matches = App::new("Proxy Generator")
                            .version(env!("CARGO_PKG_VERSION"))
                            .about("Generate proxy")
                            .arg(Arg::with_name("INPUT")
                                .help("Sets the input file to use.")
                                .required(true)
                                .index(1))
                            .arg(Arg::with_name("OUTPUT")
                                .help("Sets the output file to use.")
                                .required(true)
                                .index(2))
                            .arg(Arg::with_name("remove-prelude")
                                .long("remove-prelude")
                                .help("Remove prelude if set."))
                            .arg(Arg::with_name("inject-dependency")
                                .long("inject-dependency")
                                .help("Inject dependency if set."))
                            .arg(Arg::with_name("fix-use")
                                .long("fix-use")
                                .help("Fix use statements if set."))
                            .get_matches();


    run(matches).unwrap();
}



fn run(args: ArgMatches) -> Result<(), Box<dyn Error>> {
    let mut file = File::open(args.value_of("INPUT").ok_or(VarError::NotPresent)?)?;
    let mut content = String::new();
    file.read_to_string(&mut content)?;

    let mut ast = syn::parse_file(&content)?;

    // Remove prelude stuff
    if args.is_present("remove-prelude") {
        remove_prelude(&mut ast);
    }

    // Inject dependencies
    if args.is_present("inject-dependency") {
        inject_dependency(&mut ast)?;
    }

    // Fix imports
    if args.is_present("fix-use") {
        fix_import(&mut ast)?;
    }


    // Write output
    let output = quote!(#ast).to_string();
    std::fs::write(&args.value_of("OUTPUT").ok_or(VarError::NotPresent)?, output)?;

    Ok(())
}

/// Remove unwanted stuff generated by cargo-expand
fn remove_prelude(ast: &mut syn::File) {
    // Remove `#![feature(prelude_import)]`
    ast.attrs.retain(|attr| {
        if let Ok(Meta::List(meta)) = attr.parse_meta() {
            if !meta.path.is_ident("feature") {
                return true;
            } 

            for meta in meta.nested {
                if let NestedMeta::Meta(meta) = meta {
                    if meta.path().is_ident("prelude_import") {
                        return false;
                    }
                } 
            }
        }

        true
    });

    ast.items.retain(|item| {
        // Remove ```
        // #[prelude_import]
        // use core::prelude::v1::*;
        // ```
        if let Item::Use(item) = item {
            for attr in &item.attrs {
                if let Ok(meta) = attr.parse_meta() {
                    if meta.path().is_ident("prelude_import") {
                        return false;
                    }
                } 
            }
        }

        // Remove 
        // ```
        // #[macro_use]
        // extern crate compiler_builtins;
        // #[macro_use]
        // extern crate core;
        // ```
        if let Item::ExternCrate(item) = item {
            let ident = item.ident.to_string();
            if ident == "compiler_builtins" || ident == "core" {
                return false;
            } 
        }

        true
    });
}

/// Inject necessary dependency and features for generating the proxy
fn inject_dependency(ast: &mut syn::File) -> Result<(), Box<dyn Error>> {
    // Inject required features
    ast.attrs.push(
        parse_quote!(#![feature(global_asm, type_ascription, core_intrinsics, fmt_internals, derive_clone_copy, structural_match, rustc_private, derive_eq, extended_key_value_attributes)])
    );


    // Recursively inject import statements in each module
    for item in ast.items.iter_mut() {
        inject_import_recursive(item)?;
    }

    Ok(())
}

/// Recursively inject import statements in each module
fn inject_import_recursive(item: &mut Item) -> Result<(), Box<dyn Error>> {
    match item {
        Item::Mod(md) => {
            if let Some((_, content)) = &mut md.content {
                for item in content.iter_mut() {
                    inject_import_recursive(item)?;
                }

                let injected_import_statements: Vec<Stmt> =  parse_quote! {
                    use codegen_proc::redidl_resolve_module_and_generate_proxy as interface;
                    use codegen_proc::redidl_generate_proxy;
                    use unwind::trampoline;
                    use libsyscalls::syscalls::{sys_get_current_domain_id, sys_update_current_domain_id, sys_discard_cont};
                };
    
                let mut injected_import_statements: Vec<Item> = injected_import_statements
                                                    .into_iter()
                                                    .map(|stmt| {
                                                        match stmt {
                                                            Stmt::Item(item) => item,
                                                            _ => unreachable!(),
                                                        }
                                                    })
                                                    .collect();
                
                // Prepend the injected statments to the current statements
                injected_import_statements.append(content);
                *content = injected_import_statements;
            }
        },
        _ => {},
    };

    Ok(())
}

fn fix_import(ast: &mut syn::File) -> Result<(), Box<dyn Error>> {
    for item in ast.items.iter_mut() {
        fix_import_recursive(item)?;
    }

    Ok(())
}

/// Recursively fix import statements in each module
fn fix_import_recursive(item: &mut syn::Item) -> Result<(), Box<dyn Error>> {
    match item {
        Item::Mod(md) => {
            if let Some((_, content)) = &mut md.content {
                for item in content.iter_mut() {
                    fix_import_recursive(item)?;
                }
            }
        },
        Item::Use(item) => {
            if let syn::UseTree::Path(path) = &mut item.tree {
                if path.ident.to_string() == "crate" {
                    path.ident = syn::Ident::new(USR_LIB_NAME, path.ident.span());
                }
            }
        }
        _ => {},
    };

    Ok(())
}

